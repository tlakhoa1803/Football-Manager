// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: match.proto

package gen

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on MatchCalendar with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *MatchCalendar) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MatchCalendar with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in MatchCalendarMultiError, or
// nil if none found.
func (m *MatchCalendar) ValidateAll() error {
	return m.validate(true)
}

func (m *MatchCalendar) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for ClubOneName

	// no validation rules for ClubTwoName

	// no validation rules for IntendTime

	// no validation rules for RealTime

	// no validation rules for MatchRound

	// no validation rules for MatchTurn

	// no validation rules for IdClubOne

	// no validation rules for IdClubTwo

	// no validation rules for Season

	// no validation rules for Stadium

	// no validation rules for MatchStatus

	if len(errors) > 0 {
		return MatchCalendarMultiError(errors)
	}

	return nil
}

// MatchCalendarMultiError is an error wrapping multiple validation errors
// returned by MatchCalendar.ValidateAll() if the designated constraints
// aren't met.
type MatchCalendarMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MatchCalendarMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MatchCalendarMultiError) AllErrors() []error { return m }

// MatchCalendarValidationError is the validation error returned by
// MatchCalendar.Validate if the designated constraints aren't met.
type MatchCalendarValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MatchCalendarValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MatchCalendarValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MatchCalendarValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MatchCalendarValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MatchCalendarValidationError) ErrorName() string { return "MatchCalendarValidationError" }

// Error satisfies the builtin error interface
func (e MatchCalendarValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMatchCalendar.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MatchCalendarValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MatchCalendarValidationError{}

// Validate checks the field values on RoundRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RoundRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RoundRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RoundRequestMultiError, or
// nil if none found.
func (m *RoundRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *RoundRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Round

	if len(errors) > 0 {
		return RoundRequestMultiError(errors)
	}

	return nil
}

// RoundRequestMultiError is an error wrapping multiple validation errors
// returned by RoundRequest.ValidateAll() if the designated constraints aren't met.
type RoundRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RoundRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RoundRequestMultiError) AllErrors() []error { return m }

// RoundRequestValidationError is the validation error returned by
// RoundRequest.Validate if the designated constraints aren't met.
type RoundRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RoundRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RoundRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RoundRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RoundRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RoundRequestValidationError) ErrorName() string { return "RoundRequestValidationError" }

// Error satisfies the builtin error interface
func (e RoundRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRoundRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RoundRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RoundRequestValidationError{}

// Validate checks the field values on MatchCalendarRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MatchCalendarRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MatchCalendarRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MatchCalendarRequestMultiError, or nil if none found.
func (m *MatchCalendarRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *MatchCalendarRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if len(errors) > 0 {
		return MatchCalendarRequestMultiError(errors)
	}

	return nil
}

// MatchCalendarRequestMultiError is an error wrapping multiple validation
// errors returned by MatchCalendarRequest.ValidateAll() if the designated
// constraints aren't met.
type MatchCalendarRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MatchCalendarRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MatchCalendarRequestMultiError) AllErrors() []error { return m }

// MatchCalendarRequestValidationError is the validation error returned by
// MatchCalendarRequest.Validate if the designated constraints aren't met.
type MatchCalendarRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MatchCalendarRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MatchCalendarRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MatchCalendarRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MatchCalendarRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MatchCalendarRequestValidationError) ErrorName() string {
	return "MatchCalendarRequestValidationError"
}

// Error satisfies the builtin error interface
func (e MatchCalendarRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMatchCalendarRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MatchCalendarRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MatchCalendarRequestValidationError{}

// Validate checks the field values on StatusRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *StatusRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StatusRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in StatusRequestMultiError, or
// nil if none found.
func (m *StatusRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *StatusRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Status

	if len(errors) > 0 {
		return StatusRequestMultiError(errors)
	}

	return nil
}

// StatusRequestMultiError is an error wrapping multiple validation errors
// returned by StatusRequest.ValidateAll() if the designated constraints
// aren't met.
type StatusRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StatusRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StatusRequestMultiError) AllErrors() []error { return m }

// StatusRequestValidationError is the validation error returned by
// StatusRequest.Validate if the designated constraints aren't met.
type StatusRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StatusRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StatusRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StatusRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StatusRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StatusRequestValidationError) ErrorName() string { return "StatusRequestValidationError" }

// Error satisfies the builtin error interface
func (e StatusRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStatusRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StatusRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StatusRequestValidationError{}

// Validate checks the field values on MatchCalendarResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MatchCalendarResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MatchCalendarResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MatchCalendarResponseMultiError, or nil if none found.
func (m *MatchCalendarResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *MatchCalendarResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MatchCalendarResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MatchCalendarResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MatchCalendarResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Message

	if len(errors) > 0 {
		return MatchCalendarResponseMultiError(errors)
	}

	return nil
}

// MatchCalendarResponseMultiError is an error wrapping multiple validation
// errors returned by MatchCalendarResponse.ValidateAll() if the designated
// constraints aren't met.
type MatchCalendarResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MatchCalendarResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MatchCalendarResponseMultiError) AllErrors() []error { return m }

// MatchCalendarResponseValidationError is the validation error returned by
// MatchCalendarResponse.Validate if the designated constraints aren't met.
type MatchCalendarResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MatchCalendarResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MatchCalendarResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MatchCalendarResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MatchCalendarResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MatchCalendarResponseValidationError) ErrorName() string {
	return "MatchCalendarResponseValidationError"
}

// Error satisfies the builtin error interface
func (e MatchCalendarResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMatchCalendarResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MatchCalendarResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MatchCalendarResponseValidationError{}

// Validate checks the field values on MatchCalendarListResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MatchCalendarListResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MatchCalendarListResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MatchCalendarListResponseMultiError, or nil if none found.
func (m *MatchCalendarListResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *MatchCalendarListResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MatchCalendarListResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MatchCalendarListResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MatchCalendarListResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Message

	if len(errors) > 0 {
		return MatchCalendarListResponseMultiError(errors)
	}

	return nil
}

// MatchCalendarListResponseMultiError is an error wrapping multiple validation
// errors returned by MatchCalendarListResponse.ValidateAll() if the
// designated constraints aren't met.
type MatchCalendarListResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MatchCalendarListResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MatchCalendarListResponseMultiError) AllErrors() []error { return m }

// MatchCalendarListResponseValidationError is the validation error returned by
// MatchCalendarListResponse.Validate if the designated constraints aren't met.
type MatchCalendarListResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MatchCalendarListResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MatchCalendarListResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MatchCalendarListResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MatchCalendarListResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MatchCalendarListResponseValidationError) ErrorName() string {
	return "MatchCalendarListResponseValidationError"
}

// Error satisfies the builtin error interface
func (e MatchCalendarListResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMatchCalendarListResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MatchCalendarListResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MatchCalendarListResponseValidationError{}

// Validate checks the field values on ProgressScore with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ProgressScore) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ProgressScore with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ProgressScoreMultiError, or
// nil if none found.
func (m *ProgressScore) ValidateAll() error {
	return m.validate(true)
}

func (m *ProgressScore) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for MatchId

	// no validation rules for ClubName

	// no validation rules for PlayerName

	// no validation rules for GoalType

	// no validation rules for TimeInMatch

	if len(errors) > 0 {
		return ProgressScoreMultiError(errors)
	}

	return nil
}

// ProgressScoreMultiError is an error wrapping multiple validation errors
// returned by ProgressScore.ValidateAll() if the designated constraints
// aren't met.
type ProgressScoreMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProgressScoreMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ProgressScoreMultiError) AllErrors() []error { return m }

// ProgressScoreValidationError is the validation error returned by
// ProgressScore.Validate if the designated constraints aren't met.
type ProgressScoreValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ProgressScoreValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ProgressScoreValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ProgressScoreValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ProgressScoreValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ProgressScoreValidationError) ErrorName() string { return "ProgressScoreValidationError" }

// Error satisfies the builtin error interface
func (e ProgressScoreValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProgressScore.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ProgressScoreValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ProgressScoreValidationError{}

// Validate checks the field values on ProgressScoreListResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ProgressScoreListResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ProgressScoreListResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ProgressScoreListResponseMultiError, or nil if none found.
func (m *ProgressScoreListResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ProgressScoreListResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ProgressScoreListResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ProgressScoreListResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ProgressScoreListResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Message

	if len(errors) > 0 {
		return ProgressScoreListResponseMultiError(errors)
	}

	return nil
}

// ProgressScoreListResponseMultiError is an error wrapping multiple validation
// errors returned by ProgressScoreListResponse.ValidateAll() if the
// designated constraints aren't met.
type ProgressScoreListResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProgressScoreListResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ProgressScoreListResponseMultiError) AllErrors() []error { return m }

// ProgressScoreListResponseValidationError is the validation error returned by
// ProgressScoreListResponse.Validate if the designated constraints aren't met.
type ProgressScoreListResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ProgressScoreListResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ProgressScoreListResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ProgressScoreListResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ProgressScoreListResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ProgressScoreListResponseValidationError) ErrorName() string {
	return "ProgressScoreListResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ProgressScoreListResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProgressScoreListResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ProgressScoreListResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ProgressScoreListResponseValidationError{}

// Validate checks the field values on ProgressCard with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ProgressCard) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ProgressCard with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ProgressCardMultiError, or
// nil if none found.
func (m *ProgressCard) ValidateAll() error {
	return m.validate(true)
}

func (m *ProgressCard) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for MatchId

	// no validation rules for ClubName

	// no validation rules for PlayerName

	// no validation rules for CardType

	// no validation rules for TimeInMatch

	if len(errors) > 0 {
		return ProgressCardMultiError(errors)
	}

	return nil
}

// ProgressCardMultiError is an error wrapping multiple validation errors
// returned by ProgressCard.ValidateAll() if the designated constraints aren't met.
type ProgressCardMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProgressCardMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ProgressCardMultiError) AllErrors() []error { return m }

// ProgressCardValidationError is the validation error returned by
// ProgressCard.Validate if the designated constraints aren't met.
type ProgressCardValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ProgressCardValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ProgressCardValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ProgressCardValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ProgressCardValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ProgressCardValidationError) ErrorName() string { return "ProgressCardValidationError" }

// Error satisfies the builtin error interface
func (e ProgressCardValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProgressCard.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ProgressCardValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ProgressCardValidationError{}

// Validate checks the field values on ProgressCardListResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ProgressCardListResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ProgressCardListResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ProgressCardListResponseMultiError, or nil if none found.
func (m *ProgressCardListResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ProgressCardListResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ProgressCardListResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ProgressCardListResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ProgressCardListResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Message

	if len(errors) > 0 {
		return ProgressCardListResponseMultiError(errors)
	}

	return nil
}

// ProgressCardListResponseMultiError is an error wrapping multiple validation
// errors returned by ProgressCardListResponse.ValidateAll() if the designated
// constraints aren't met.
type ProgressCardListResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProgressCardListResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ProgressCardListResponseMultiError) AllErrors() []error { return m }

// ProgressCardListResponseValidationError is the validation error returned by
// ProgressCardListResponse.Validate if the designated constraints aren't met.
type ProgressCardListResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ProgressCardListResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ProgressCardListResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ProgressCardListResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ProgressCardListResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ProgressCardListResponseValidationError) ErrorName() string {
	return "ProgressCardListResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ProgressCardListResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProgressCardListResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ProgressCardListResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ProgressCardListResponseValidationError{}

// Validate checks the field values on ResultScore with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ResultScore) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ResultScore with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ResultScoreMultiError, or
// nil if none found.
func (m *ResultScore) ValidateAll() error {
	return m.validate(true)
}

func (m *ResultScore) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for MatchId

	// no validation rules for HomeTeamGoal

	// no validation rules for AwayTeamGoal

	// no validation rules for HomeTeam

	// no validation rules for AwayTeam

	// no validation rules for YellowCardHome

	// no validation rules for YellowCardAway

	// no validation rules for RedCardHome

	// no validation rules for RedCardAway

	// no validation rules for MatchRound

	// no validation rules for Stadium

	// no validation rules for Capacity

	// no validation rules for Score

	// no validation rules for HomeLogo

	// no validation rules for AwayLogo

	// no validation rules for Time

	// no validation rules for SeaSon

	if len(errors) > 0 {
		return ResultScoreMultiError(errors)
	}

	return nil
}

// ResultScoreMultiError is an error wrapping multiple validation errors
// returned by ResultScore.ValidateAll() if the designated constraints aren't met.
type ResultScoreMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ResultScoreMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ResultScoreMultiError) AllErrors() []error { return m }

// ResultScoreValidationError is the validation error returned by
// ResultScore.Validate if the designated constraints aren't met.
type ResultScoreValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ResultScoreValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ResultScoreValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ResultScoreValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ResultScoreValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ResultScoreValidationError) ErrorName() string { return "ResultScoreValidationError" }

// Error satisfies the builtin error interface
func (e ResultScoreValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sResultScore.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ResultScoreValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ResultScoreValidationError{}

// Validate checks the field values on ResultScoreRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ResultScoreRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ResultScoreRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ResultScoreRequestMultiError, or nil if none found.
func (m *ResultScoreRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ResultScoreRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for MatchId

	if len(errors) > 0 {
		return ResultScoreRequestMultiError(errors)
	}

	return nil
}

// ResultScoreRequestMultiError is an error wrapping multiple validation errors
// returned by ResultScoreRequest.ValidateAll() if the designated constraints
// aren't met.
type ResultScoreRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ResultScoreRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ResultScoreRequestMultiError) AllErrors() []error { return m }

// ResultScoreRequestValidationError is the validation error returned by
// ResultScoreRequest.Validate if the designated constraints aren't met.
type ResultScoreRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ResultScoreRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ResultScoreRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ResultScoreRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ResultScoreRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ResultScoreRequestValidationError) ErrorName() string {
	return "ResultScoreRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ResultScoreRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sResultScoreRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ResultScoreRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ResultScoreRequestValidationError{}

// Validate checks the field values on SumScore with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SumScore) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SumScore with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SumScoreMultiError, or nil
// if none found.
func (m *SumScore) ValidateAll() error {
	return m.validate(true)
}

func (m *SumScore) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for MatchId

	// no validation rules for HomeTeamGoal

	// no validation rules for HomeTeamName

	// no validation rules for AwayTeamGoal

	// no validation rules for AwayTeamName

	// no validation rules for MatchRound

	// no validation rules for Time

	// no validation rules for Stadium

	// no validation rules for Score

	// no validation rules for HomeLogo

	// no validation rules for AwayLogo

	// no validation rules for HomeTeamFullName

	// no validation rules for AwayTeamFullName

	if len(errors) > 0 {
		return SumScoreMultiError(errors)
	}

	return nil
}

// SumScoreMultiError is an error wrapping multiple validation errors returned
// by SumScore.ValidateAll() if the designated constraints aren't met.
type SumScoreMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SumScoreMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SumScoreMultiError) AllErrors() []error { return m }

// SumScoreValidationError is the validation error returned by
// SumScore.Validate if the designated constraints aren't met.
type SumScoreValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SumScoreValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SumScoreValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SumScoreValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SumScoreValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SumScoreValidationError) ErrorName() string { return "SumScoreValidationError" }

// Error satisfies the builtin error interface
func (e SumScoreValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSumScore.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SumScoreValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SumScoreValidationError{}

// Validate checks the field values on ResultScoreResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ResultScoreResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ResultScoreResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ResultScoreResponseMultiError, or nil if none found.
func (m *ResultScoreResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ResultScoreResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ResultScoreResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ResultScoreResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ResultScoreResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Message

	if len(errors) > 0 {
		return ResultScoreResponseMultiError(errors)
	}

	return nil
}

// ResultScoreResponseMultiError is an error wrapping multiple validation
// errors returned by ResultScoreResponse.ValidateAll() if the designated
// constraints aren't met.
type ResultScoreResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ResultScoreResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ResultScoreResponseMultiError) AllErrors() []error { return m }

// ResultScoreResponseValidationError is the validation error returned by
// ResultScoreResponse.Validate if the designated constraints aren't met.
type ResultScoreResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ResultScoreResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ResultScoreResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ResultScoreResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ResultScoreResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ResultScoreResponseValidationError) ErrorName() string {
	return "ResultScoreResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ResultScoreResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sResultScoreResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ResultScoreResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ResultScoreResponseValidationError{}

// Validate checks the field values on ResultScoreListResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ResultScoreListResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ResultScoreListResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ResultScoreListResponseMultiError, or nil if none found.
func (m *ResultScoreListResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ResultScoreListResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ResultScoreListResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ResultScoreListResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ResultScoreListResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Message

	if len(errors) > 0 {
		return ResultScoreListResponseMultiError(errors)
	}

	return nil
}

// ResultScoreListResponseMultiError is an error wrapping multiple validation
// errors returned by ResultScoreListResponse.ValidateAll() if the designated
// constraints aren't met.
type ResultScoreListResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ResultScoreListResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ResultScoreListResponseMultiError) AllErrors() []error { return m }

// ResultScoreListResponseValidationError is the validation error returned by
// ResultScoreListResponse.Validate if the designated constraints aren't met.
type ResultScoreListResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ResultScoreListResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ResultScoreListResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ResultScoreListResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ResultScoreListResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ResultScoreListResponseValidationError) ErrorName() string {
	return "ResultScoreListResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ResultScoreListResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sResultScoreListResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ResultScoreListResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ResultScoreListResponseValidationError{}

// Validate checks the field values on ResultSumScoreListResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ResultSumScoreListResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ResultSumScoreListResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ResultSumScoreListResponseMultiError, or nil if none found.
func (m *ResultSumScoreListResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ResultSumScoreListResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ResultSumScoreListResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ResultSumScoreListResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ResultSumScoreListResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Message

	if len(errors) > 0 {
		return ResultSumScoreListResponseMultiError(errors)
	}

	return nil
}

// ResultSumScoreListResponseMultiError is an error wrapping multiple
// validation errors returned by ResultSumScoreListResponse.ValidateAll() if
// the designated constraints aren't met.
type ResultSumScoreListResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ResultSumScoreListResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ResultSumScoreListResponseMultiError) AllErrors() []error { return m }

// ResultSumScoreListResponseValidationError is the validation error returned
// by ResultSumScoreListResponse.Validate if the designated constraints aren't met.
type ResultSumScoreListResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ResultSumScoreListResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ResultSumScoreListResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ResultSumScoreListResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ResultSumScoreListResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ResultSumScoreListResponseValidationError) ErrorName() string {
	return "ResultSumScoreListResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ResultSumScoreListResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sResultSumScoreListResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ResultSumScoreListResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ResultSumScoreListResponseValidationError{}

// Validate checks the field values on Player with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Player) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Player with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in PlayerMultiError, or nil if none found.
func (m *Player) ValidateAll() error {
	return m.validate(true)
}

func (m *Player) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PlayerNameCard

	// no validation rules for CardType

	// no validation rules for TimeInMatchCard

	// no validation rules for PlayerNameGoal

	// no validation rules for GoalType

	// no validation rules for TimeInMatchGoal

	if len(errors) > 0 {
		return PlayerMultiError(errors)
	}

	return nil
}

// PlayerMultiError is an error wrapping multiple validation errors returned by
// Player.ValidateAll() if the designated constraints aren't met.
type PlayerMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PlayerMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PlayerMultiError) AllErrors() []error { return m }

// PlayerValidationError is the validation error returned by Player.Validate if
// the designated constraints aren't met.
type PlayerValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PlayerValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PlayerValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PlayerValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PlayerValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PlayerValidationError) ErrorName() string { return "PlayerValidationError" }

// Error satisfies the builtin error interface
func (e PlayerValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPlayer.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PlayerValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PlayerValidationError{}

// Validate checks the field values on Team with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Team) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Team with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in TeamMultiError, or nil if none found.
func (m *Team) ValidateAll() error {
	return m.validate(true)
}

func (m *Team) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Logo

	// no validation rules for Goals

	for idx, item := range m.GetPlayers() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TeamValidationError{
						field:  fmt.Sprintf("Players[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TeamValidationError{
						field:  fmt.Sprintf("Players[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TeamValidationError{
					field:  fmt.Sprintf("Players[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return TeamMultiError(errors)
	}

	return nil
}

// TeamMultiError is an error wrapping multiple validation errors returned by
// Team.ValidateAll() if the designated constraints aren't met.
type TeamMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TeamMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TeamMultiError) AllErrors() []error { return m }

// TeamValidationError is the validation error returned by Team.Validate if the
// designated constraints aren't met.
type TeamValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TeamValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TeamValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TeamValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TeamValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TeamValidationError) ErrorName() string { return "TeamValidationError" }

// Error satisfies the builtin error interface
func (e TeamValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTeam.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TeamValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TeamValidationError{}

// Validate checks the field values on ProgressGoal with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ProgressGoal) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ProgressGoal with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ProgressGoalMultiError, or
// nil if none found.
func (m *ProgressGoal) ValidateAll() error {
	return m.validate(true)
}

func (m *ProgressGoal) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for MatchId

	// no validation rules for Stadium

	// no validation rules for Time

	// no validation rules for Capacity

	if all {
		switch v := interface{}(m.GetHomeTeam()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ProgressGoalValidationError{
					field:  "HomeTeam",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ProgressGoalValidationError{
					field:  "HomeTeam",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetHomeTeam()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ProgressGoalValidationError{
				field:  "HomeTeam",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetAwayTeam()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ProgressGoalValidationError{
					field:  "AwayTeam",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ProgressGoalValidationError{
					field:  "AwayTeam",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAwayTeam()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ProgressGoalValidationError{
				field:  "AwayTeam",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ProgressGoalMultiError(errors)
	}

	return nil
}

// ProgressGoalMultiError is an error wrapping multiple validation errors
// returned by ProgressGoal.ValidateAll() if the designated constraints aren't met.
type ProgressGoalMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProgressGoalMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ProgressGoalMultiError) AllErrors() []error { return m }

// ProgressGoalValidationError is the validation error returned by
// ProgressGoal.Validate if the designated constraints aren't met.
type ProgressGoalValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ProgressGoalValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ProgressGoalValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ProgressGoalValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ProgressGoalValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ProgressGoalValidationError) ErrorName() string { return "ProgressGoalValidationError" }

// Error satisfies the builtin error interface
func (e ProgressGoalValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProgressGoal.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ProgressGoalValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ProgressGoalValidationError{}

// Validate checks the field values on GoalType with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GoalType) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GoalType with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GoalTypeMultiError, or nil
// if none found.
func (m *GoalType) ValidateAll() error {
	return m.validate(true)
}

func (m *GoalType) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for GoalTypeId

	// no validation rules for GoalTypeName

	if len(errors) > 0 {
		return GoalTypeMultiError(errors)
	}

	return nil
}

// GoalTypeMultiError is an error wrapping multiple validation errors returned
// by GoalType.ValidateAll() if the designated constraints aren't met.
type GoalTypeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GoalTypeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GoalTypeMultiError) AllErrors() []error { return m }

// GoalTypeValidationError is the validation error returned by
// GoalType.Validate if the designated constraints aren't met.
type GoalTypeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GoalTypeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GoalTypeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GoalTypeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GoalTypeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GoalTypeValidationError) ErrorName() string { return "GoalTypeValidationError" }

// Error satisfies the builtin error interface
func (e GoalTypeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGoalType.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GoalTypeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GoalTypeValidationError{}

// Validate checks the field values on CardType with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CardType) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CardType with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CardTypeMultiError, or nil
// if none found.
func (m *CardType) ValidateAll() error {
	return m.validate(true)
}

func (m *CardType) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CardTypeId

	// no validation rules for CardTypeName

	if len(errors) > 0 {
		return CardTypeMultiError(errors)
	}

	return nil
}

// CardTypeMultiError is an error wrapping multiple validation errors returned
// by CardType.ValidateAll() if the designated constraints aren't met.
type CardTypeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CardTypeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CardTypeMultiError) AllErrors() []error { return m }

// CardTypeValidationError is the validation error returned by
// CardType.Validate if the designated constraints aren't met.
type CardTypeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CardTypeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CardTypeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CardTypeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CardTypeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CardTypeValidationError) ErrorName() string { return "CardTypeValidationError" }

// Error satisfies the builtin error interface
func (e CardTypeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCardType.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CardTypeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CardTypeValidationError{}

// Validate checks the field values on GoalTypeResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GoalTypeResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GoalTypeResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GoalTypeResponseMultiError, or nil if none found.
func (m *GoalTypeResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GoalTypeResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GoalTypeResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GoalTypeResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GoalTypeResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Message

	if len(errors) > 0 {
		return GoalTypeResponseMultiError(errors)
	}

	return nil
}

// GoalTypeResponseMultiError is an error wrapping multiple validation errors
// returned by GoalTypeResponse.ValidateAll() if the designated constraints
// aren't met.
type GoalTypeResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GoalTypeResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GoalTypeResponseMultiError) AllErrors() []error { return m }

// GoalTypeResponseValidationError is the validation error returned by
// GoalTypeResponse.Validate if the designated constraints aren't met.
type GoalTypeResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GoalTypeResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GoalTypeResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GoalTypeResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GoalTypeResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GoalTypeResponseValidationError) ErrorName() string { return "GoalTypeResponseValidationError" }

// Error satisfies the builtin error interface
func (e GoalTypeResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGoalTypeResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GoalTypeResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GoalTypeResponseValidationError{}

// Validate checks the field values on CardTypeResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CardTypeResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CardTypeResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CardTypeResponseMultiError, or nil if none found.
func (m *CardTypeResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CardTypeResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CardTypeResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CardTypeResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CardTypeResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Message

	if len(errors) > 0 {
		return CardTypeResponseMultiError(errors)
	}

	return nil
}

// CardTypeResponseMultiError is an error wrapping multiple validation errors
// returned by CardTypeResponse.ValidateAll() if the designated constraints
// aren't met.
type CardTypeResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CardTypeResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CardTypeResponseMultiError) AllErrors() []error { return m }

// CardTypeResponseValidationError is the validation error returned by
// CardTypeResponse.Validate if the designated constraints aren't met.
type CardTypeResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CardTypeResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CardTypeResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CardTypeResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CardTypeResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CardTypeResponseValidationError) ErrorName() string { return "CardTypeResponseValidationError" }

// Error satisfies the builtin error interface
func (e CardTypeResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCardTypeResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CardTypeResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CardTypeResponseValidationError{}

// Validate checks the field values on MatchCalendarResponse_Data with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MatchCalendarResponse_Data) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MatchCalendarResponse_Data with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MatchCalendarResponse_DataMultiError, or nil if none found.
func (m *MatchCalendarResponse_Data) ValidateAll() error {
	return m.validate(true)
}

func (m *MatchCalendarResponse_Data) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ClubOneName

	// no validation rules for ClubTwoName

	// no validation rules for IntendTime

	// no validation rules for RealTime

	// no validation rules for MatchRound

	// no validation rules for MatchTurn

	// no validation rules for Stadium

	// no validation rules for Season

	// no validation rules for MatchStatus

	// no validation rules for MatchId

	if len(errors) > 0 {
		return MatchCalendarResponse_DataMultiError(errors)
	}

	return nil
}

// MatchCalendarResponse_DataMultiError is an error wrapping multiple
// validation errors returned by MatchCalendarResponse_Data.ValidateAll() if
// the designated constraints aren't met.
type MatchCalendarResponse_DataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MatchCalendarResponse_DataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MatchCalendarResponse_DataMultiError) AllErrors() []error { return m }

// MatchCalendarResponse_DataValidationError is the validation error returned
// by MatchCalendarResponse_Data.Validate if the designated constraints aren't met.
type MatchCalendarResponse_DataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MatchCalendarResponse_DataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MatchCalendarResponse_DataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MatchCalendarResponse_DataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MatchCalendarResponse_DataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MatchCalendarResponse_DataValidationError) ErrorName() string {
	return "MatchCalendarResponse_DataValidationError"
}

// Error satisfies the builtin error interface
func (e MatchCalendarResponse_DataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMatchCalendarResponse_Data.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MatchCalendarResponse_DataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MatchCalendarResponse_DataValidationError{}
